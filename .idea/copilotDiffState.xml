<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/gaia/commands.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/gaia/commands.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;tea &quot;github.com/charmbracelet/bubbletea&quot;&#10;&#9;&quot;github.com/charmbracelet/huh&quot;&#10;&#9;&quot;github.com/charmbracelet/lipgloss&quot;&#10;&#9;&quot;github.com/stain-win/gaia/apps/gaia/daemon&quot;&#10;)&#10;&#10;// Define styles for the UI.&#10;var (&#10;&#9;titleStyle = lipgloss.NewStyle().&#10;&#9;&#9;&#9;Bold(true).&#10;&#9;&#9;&#9;Foreground(lipgloss.Color(&quot;#FF8C00&quot;)). // Orange&#10;&#9;&#9;&#9;PaddingLeft(1)&#10;&#10;&#9;promptStyle = lipgloss.NewStyle().&#10;&#9;&#9;&#9;Foreground(lipgloss.Color(&quot;#00BFFF&quot;)). // Deep Sky Blue&#10;&#9;&#9;&#9;PaddingRight(1)&#10;&#10;&#9;helpStyle = lipgloss.NewStyle().&#10;&#9;&#9;&#9;Foreground(lipgloss.Color(&quot;241&quot;)). // Light Gray&#10;&#9;&#9;&#9;MarginTop(1)                       // Add one line of top padding&#10;&#10;&#9;appStyle = lipgloss.NewStyle().Margin(1, 2)&#10;)&#10;&#10;func _validatePassphrase(passphrase string) error {&#10;&#9;if len(passphrase) &lt; 8 {&#10;&#9;&#9;return errors.New(&quot;passphrase must be at least 8 characters&quot;)&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// A new Bubble Tea model to handle the interactive passphrase input.&#10;type initModel struct {&#10;&#9;form       *huh.Form&#10;&#9;passphrase string&#10;}&#10;&#10;func newInitModel() initModel {&#10;&#9;var passphrase string&#10;&#10;&#9;// The key fix: wrap huh.NewInput in a huh.Group and then a huh.Form.&#10;&#9;// You can also give the field a key like &quot;passphrase&quot; for easy access later.&#10;&#9;form := huh.NewForm(&#10;&#9;&#9;huh.NewGroup(&#10;&#9;&#9;&#9;huh.NewInput().&#10;&#9;&#9;&#9;&#9;Title(titleStyle.Render(&quot;Enter master passphrase&quot;)).&#10;&#9;&#9;&#9;&#9;Prompt(promptStyle.Render(&quot;?&quot;)).&#10;&#9;&#9;&#9;&#9;Validate(_validatePassphrase).&#10;&#9;&#9;&#9;&#9;Value(&amp;passphrase),&#10;&#9;&#9;),&#10;&#9;).WithWidth(40)&#10;&#10;&#9;return initModel{&#10;&#9;&#9;form:       form,&#10;&#9;&#9;passphrase: passphrase,&#10;&#9;}&#10;}&#10;&#10;func (m initModel) Init() tea.Cmd {&#10;&#9;return m.form.Init()&#10;}&#10;&#10;func (m initModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {&#10;&#9;var cmd tea.Cmd&#10;&#9;m.form, cmd = m.form.Update(msg)&#10;&#10;&#9;if m.form.State == huh.StateCompleted {&#10;&#9;&#9;m.passphrase = m.form.GetString(&quot;passphrase&quot;)&#10;&#9;&#9;return m, tea.Quit&#10;&#9;}&#10;&#10;&#9;// Capture Ctrl+C for a clean exit.&#10;&#9;if msg, ok := msg.(tea.KeyMsg); ok &amp;&amp; msg.String() == &quot;ctrl+c&quot; {&#10;&#9;&#9;return m, tea.Quit&#10;&#9;}&#10;&#10;&#9;return m, cmd&#10;}&#10;&#10;func (m initModel) View() string {&#10;&#9;// Render the form and append the styled help message below it.&#10;&#9;return appStyle.Render(&#10;&#9;&#9;lipgloss.JoinVertical(lipgloss.Left,&#10;&#9;&#9;&#9;m.form.View(),&#10;&#9;&#9;&#9;helpStyle.Render(&quot;Press Ctrl+C to quit&quot;),&#10;&#9;&#9;),&#10;&#9;)&#10;}&#10;&#10;// The refactored initCmd function.&#10;func initCmd() {&#10;&#9;fmt.Println(&quot;Initializing Gaia secure storage...&quot;)&#10;&#10;&#9;p := tea.NewProgram(newInitModel(), tea.WithAltScreen())&#10;&#9;finalModel, err := p.Run()&#10;&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Initialization cancelled or failed:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Assert the type to access the passphrase field.&#10;&#9;if completedModel, ok := finalModel.(initModel); ok {&#10;&#9;&#9;passphrase := strings.TrimSpace(completedModel.passphrase)&#10;&#9;&#9;if passphrase == &quot;&quot; {&#10;&#9;&#9;&#9;fmt.Println(&quot;Initialization cancelled.&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;err = daemon.InitializeDB(passphrase)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Println(&quot;Failed to initialize database:&quot;, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;fmt.Println(&quot;Gaia encrypted database initialized.&quot;)&#10;&#9;&#9;fmt.Printf(&quot;Master passphrase set: '%s'\n&quot;, passphrase)&#10;&#9;}&#10;}&#10;&#10;func stopCmd() {&#10;&#9;fmt.Println(&quot;Running gaia stop...&quot;)&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;err := daemon.Stop(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Failed to stop daemon:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;fmt.Println(&quot;Gaia daemon stopped.&quot;)&#10;}&#10;&#10;func restartCmd() {&#10;&#9;fmt.Println(&quot;Running gaia restart...&quot;)&#10;}&#10;&#10;func statusCmd() {&#10;&#9;fmt.Println(&quot;Running gaia status...&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;tea &quot;github.com/charmbracelet/bubbletea&quot;&#10;&#9;&quot;github.com/charmbracelet/huh&quot;&#10;&#9;&quot;github.com/charmbracelet/lipgloss&quot;&#10;&#9;&quot;github.com/stain-win/gaia/apps/gaia/daemon&quot;&#10;)&#10;&#10;// Define styles for the UI.&#10;var (&#10;&#9;titleStyle = lipgloss.NewStyle().&#10;&#9;&#9;&#9;Bold(true).&#10;&#9;&#9;&#9;Foreground(lipgloss.Color(&quot;#FF8C00&quot;)). // Orange&#10;&#9;&#9;&#9;PaddingLeft(1)&#10;&#10;&#9;promptStyle = lipgloss.NewStyle().&#10;&#9;&#9;&#9;Foreground(lipgloss.Color(&quot;#00BFFF&quot;)). // Deep Sky Blue&#10;&#9;&#9;&#9;PaddingRight(1)&#10;&#10;&#9;helpStyle = lipgloss.NewStyle().&#10;&#9;&#9;&#9;Foreground(lipgloss.Color(&quot;241&quot;)). // Light Gray&#10;&#9;&#9;&#9;MarginTop(1)                       // Add one line of top padding&#10;&#10;&#9;appStyle = lipgloss.NewStyle().Margin(1, 2)&#10;)&#10;&#10;func _validatePassphrase(passphrase string) error {&#10;&#9;if len(passphrase) &lt; 8 {&#10;&#9;&#9;return errors.New(&quot;passphrase must be at least 8 characters&quot;)&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// A new Bubble Tea model to handle the interactive passphrase input.&#10;type initModel struct {&#10;&#9;form       *huh.Form&#10;&#9;passphrase string&#10;}&#10;&#10;func newInitModel() initModel {&#10;&#9;var passphrase string&#10;&#10;&#9;// The key fix: wrap huh.NewInput in a huh.Group and then a huh.Form.&#10;&#9;// You can also give the field a key like &quot;passphrase&quot; for easy access later.&#10;&#9;form := huh.NewForm(&#10;&#9;&#9;huh.NewGroup(&#10;&#9;&#9;&#9;huh.NewInput().&#10;&#9;&#9;&#9;&#9;Title(titleStyle.Render(&quot;Enter master passphrase&quot;)).&#10;&#9;&#9;&#9;&#9;Prompt(promptStyle.Render(&quot;?&quot;)).&#10;&#9;&#9;&#9;&#9;Validate(_validatePassphrase).&#10;&#9;&#9;&#9;&#9;Value(&amp;passphrase),&#10;&#9;&#9;),&#10;&#9;).WithWidth(40)&#10;&#10;&#9;return initModel{&#10;&#9;&#9;form:       form,&#10;&#9;&#9;passphrase: passphrase,&#10;&#9;}&#10;}&#10;&#10;func (m initModel) Init() tea.Cmd {&#10;&#9;return m.form.Init()&#10;}&#10;&#10;func (m initModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {&#10;&#9;var cmd tea.Cmd&#10;&#9;m.form, cmd = m.form.Update(msg)&#10;&#10;&#9;if m.form.State == huh.StateCompleted {&#10;&#9;&#9;m.passphrase = m.form.GetString(&quot;passphrase&quot;)&#10;&#9;&#9;return m, tea.Quit&#10;&#9;}&#10;&#10;&#9;// Capture Ctrl+C for a clean exit.&#10;&#9;if msg, ok := msg.(tea.KeyMsg); ok &amp;&amp; msg.String() == &quot;ctrl+c&quot; {&#10;&#9;&#9;return m, tea.Quit&#10;&#9;}&#10;&#10;&#9;return m, cmd&#10;}&#10;&#10;func (m initModel) View() string {&#10;&#9;// Render the form and append the styled help message below it.&#10;&#9;return appStyle.Render(&#10;&#9;&#9;lipgloss.JoinVertical(lipgloss.Left,&#10;&#9;&#9;&#9;m.form.View(),&#10;&#9;&#9;&#9;helpStyle.Render(&quot;Press Ctrl+C to quit&quot;),&#10;&#9;&#9;),&#10;&#9;)&#10;}&#10;&#10;// The refactored initCmd function.&#10;func initCmd() {&#10;&#9;fmt.Println(&quot;Initializing Gaia secure storage...&quot;)&#10;&#10;&#9;p := tea.NewProgram(newInitModel(), tea.WithAltScreen())&#10;&#9;finalModel, err := p.Run()&#10;&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Initialization cancelled or failed:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Assert the type to access the passphrase field.&#10;&#9;if completedModel, ok := finalModel.(initModel); ok {&#10;&#9;&#9;passphrase := strings.TrimSpace(completedModel.passphrase)&#10;&#9;&#9;if passphrase == &quot;&quot; {&#10;&#9;&#9;&#9;fmt.Println(&quot;Initialization cancelled.&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;err = daemon.InitializeDB(passphrase)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Println(&quot;Failed to initialize database:&quot;, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;fmt.Println(&quot;Gaia encrypted database initialized.&quot;)&#10;&#9;&#9;fmt.Printf(&quot;Master passphrase set: '%s'\n&quot;, passphrase)&#10;&#9;}&#10;}&#10;&#10;func stopCmd() {&#10;&#9;fmt.Println(&quot;Running gaia stop...&quot;)&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;err := daemon.Stop(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Failed to stop daemon:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;fmt.Println(&quot;Gaia daemon stopped.&quot;)&#10;}&#10;&#10;func restartCmd() {&#10;&#9;fmt.Println(&quot;Running gaia restart...&quot;)&#10;}&#10;&#10;func statusCmd() {&#10;&#9;fmt.Println(&quot;Running gaia status...&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/gaia/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/gaia/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;bufio&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/stain-win/gaia/apps/gaia/daemon&quot;&#10;&#9;&quot;github.com/stain-win/gaia/apps/gaia/tui&quot;&#10;)&#10;&#10;func main() {&#10;&#9;if len(os.Args) &lt; 2 {&#10;&#9;&#9;err := tui.Run()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Println(&quot;TUI exited with error:&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;cmd := os.Args[1]&#10;&#9;switch cmd {&#10;&#9;case &quot;init&quot;:&#10;&#9;&#9;initCmd()&#10;&#9;case &quot;start&quot;:&#10;&#9;&#9;startCmd()&#10;&#9;case &quot;stop&quot;:&#10;&#9;&#9;stopCmd()&#10;&#9;case &quot;restart&quot;:&#10;&#9;&#9;restartCmd()&#10;&#9;case &quot;status&quot;:&#10;&#9;&#9;statusCmd()&#10;&#9;default:&#10;&#9;&#9;fmt.Println(&quot;Unknown command:&quot;, cmd)&#10;&#9;&#9;fmt.Println(&quot;Usage: gaia [init|start|stop|restart|status]&quot;)&#10;&#9;}&#10;}&#10;&#10;func initCmd() {&#10;&#9;fmt.Println(&quot;Initializing Gaia secure storage...&quot;)&#10;&#9;reader := bufio.NewReader(os.Stdin)&#10;&#9;fmt.Print(&quot;Enter master passphrase: &quot;)&#10;&#9;passphrase, _ := reader.ReadString('\n')&#10;&#9;passphrase = strings.TrimSpace(passphrase)&#10;&#9;if len(passphrase) &lt; 8 {&#10;&#9;&#9;fmt.Println(&quot;Passphrase must be at least 8 characters.&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;err := daemon.InitializeDB(passphrase)&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Failed to initialize database:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;fmt.Println(&quot;Gaia encrypted database initialized.&quot;)&#10;}&#10;&#10;func startCmd() {&#10;&#9;fmt.Println(&quot;Running gaia start...&quot;)&#10;&#9;if err := daemon.Init(); err != nil {&#10;&#9;&#9;fmt.Println(&quot;Daemon init failed:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;go func() {&#10;&#9;&#9;err := daemon.Start()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;Daemon failed to start: %v&quot;, err)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#9;fmt.Println(&quot;Gaia daemon launched in background.&quot;)&#10;}&#10;&#10;func stopCmd() {&#10;&#9;fmt.Println(&quot;Running gaia stop...&quot;)&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;err := daemon.Stop(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Failed to stop daemon:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;fmt.Println(&quot;Gaia daemon stopped.&quot;)&#10;}&#10;&#10;func restartCmd() {&#10;&#9;fmt.Println(&quot;Running gaia restart...&quot;)&#10;}&#10;&#10;func statusCmd() {&#10;&#9;fmt.Println(&quot;Running gaia status...&quot;)&#10;}&#10;&#10;func interactiveMode() {&#10;&#9;fmt.Println(&quot;Gaia interactive mode. Enter a command (init, start, stop, restart, status):&quot;)&#10;&#9;var cmd string&#10;&#9;for {&#10;&#9;&#9;fmt.Print(&quot;&gt; &quot;)&#10;&#9;&#9;_, err := fmt.Scanln(&amp;cmd)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Println(&quot;Error reading input:&quot;, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;switch cmd {&#10;&#9;&#9;case &quot;init&quot;:&#10;&#9;&#9;&#9;initCmd()&#10;&#9;&#9;case &quot;start&quot;:&#10;&#9;&#9;&#9;startCmd()&#10;&#9;&#9;case &quot;stop&quot;:&#10;&#9;&#9;&#9;stopCmd()&#10;&#9;&#9;case &quot;restart&quot;:&#10;&#9;&#9;&#9;restartCmd()&#10;&#9;&#9;case &quot;status&quot;:&#10;&#9;&#9;&#9;statusCmd()&#10;&#9;&#9;case &quot;exit&quot;, &quot;quit&quot;:&#10;&#9;&#9;&#9;fmt.Println(&quot;Exiting interactive mode.&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;fmt.Println(&quot;Unknown command:&quot;, cmd)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;bufio&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/stain-win/gaia/apps/gaia/daemon&quot;&#10;&#9;&quot;github.com/stain-win/gaia/apps/gaia/tui&quot;&#10;)&#10;&#10;func main() {&#10;&#9;if len(os.Args) &lt; 2 {&#10;&#9;&#9;err := tui.Run()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;if strings.Contains(err.Error(), &quot;open /dev/tty&quot;) {&#10;&#9;&#9;&#9;&#9;fmt.Println(&quot;Error: Could not open a new TTY. Please run Gaia in a real terminal (not in an IDE or redirected environment).\nDetails:&quot;, err)&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;fmt.Println(&quot;TUI exited with error:&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;cmd := os.Args[1]&#10;&#9;switch cmd {&#10;&#9;case &quot;init&quot;:&#10;&#9;&#9;initCmd()&#10;&#9;case &quot;start&quot;:&#10;&#9;&#9;startCmd()&#10;&#9;case &quot;stop&quot;:&#10;&#9;&#9;stopCmd()&#10;&#9;case &quot;restart&quot;:&#10;&#9;&#9;restartCmd()&#10;&#9;case &quot;status&quot;:&#10;&#9;&#9;statusCmd()&#10;&#9;default:&#10;&#9;&#9;fmt.Println(&quot;Unknown command:&quot;, cmd)&#10;&#9;&#9;fmt.Println(&quot;Usage: gaia [init|start|stop|restart|status]&quot;)&#10;&#9;}&#10;}&#10;&#10;func initCmd() {&#10;&#9;fmt.Println(&quot;Initializing Gaia secure storage...&quot;)&#10;&#9;reader := bufio.NewReader(os.Stdin)&#10;&#9;fmt.Print(&quot;Enter master passphrase: &quot;)&#10;&#9;passphrase, _ := reader.ReadString('\n')&#10;&#9;passphrase = strings.TrimSpace(passphrase)&#10;&#9;if len(passphrase) &lt; 8 {&#10;&#9;&#9;fmt.Println(&quot;Passphrase must be at least 8 characters.&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;err := daemon.InitializeDB(passphrase)&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Failed to initialize database:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;fmt.Println(&quot;Gaia encrypted database initialized.&quot;)&#10;}&#10;&#10;func startCmd() {&#10;&#9;fmt.Println(&quot;Running gaia start...&quot;)&#10;&#9;if err := daemon.Init(); err != nil {&#10;&#9;&#9;fmt.Println(&quot;Daemon init failed:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;go func() {&#10;&#9;&#9;err := daemon.Start()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;Daemon failed to start: %v&quot;, err)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#9;fmt.Println(&quot;Gaia daemon launched in background.&quot;)&#10;}&#10;&#10;func stopCmd() {&#10;&#9;fmt.Println(&quot;Running gaia stop...&quot;)&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;err := daemon.Stop(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Failed to stop daemon:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;fmt.Println(&quot;Gaia daemon stopped.&quot;)&#10;}&#10;&#10;func restartCmd() {&#10;&#9;fmt.Println(&quot;Running gaia restart...&quot;)&#10;}&#10;&#10;func statusCmd() {&#10;&#9;fmt.Println(&quot;Running gaia status...&quot;)&#10;}&#10;&#10;func interactiveMode() {&#10;&#9;fmt.Println(&quot;Gaia interactive mode. Enter a command (init, start, stop, restart, status):&quot;)&#10;&#9;var cmd string&#10;&#9;for {&#10;&#9;&#9;fmt.Print(&quot;&gt; &quot;)&#10;&#9;&#9;_, err := fmt.Scanln(&amp;cmd)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Println(&quot;Error reading input:&quot;, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;switch cmd {&#10;&#9;&#9;case &quot;init&quot;:&#10;&#9;&#9;&#9;initCmd()&#10;&#9;&#9;case &quot;start&quot;:&#10;&#9;&#9;&#9;startCmd()&#10;&#9;&#9;case &quot;stop&quot;:&#10;&#9;&#9;&#9;stopCmd()&#10;&#9;&#9;case &quot;restart&quot;:&#10;&#9;&#9;&#9;restartCmd()&#10;&#9;&#9;case &quot;status&quot;:&#10;&#9;&#9;&#9;statusCmd()&#10;&#9;&#9;case &quot;exit&quot;, &quot;quit&quot;:&#10;&#9;&#9;&#9;fmt.Println(&quot;Exiting interactive mode.&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;fmt.Println(&quot;Unknown command:&quot;, cmd)&#10;&#9;&#9;}&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/gaia/tui/tui.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/gaia/tui/tui.go" />
              <option name="originalContent" value="package tui&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;tea &quot;github.com/charmbracelet/bubbletea&quot;&#10;&#9;&quot;github.com/charmbracelet/huh&quot;&#10;&#9;&quot;github.com/charmbracelet/lipgloss&quot;&#10;)&#10;&#10;type screen int&#10;&#10;const (&#10;&#9;mainMenu screen = iota&#10;&#9;addRecord&#10;&#9;certManagement&#10;)&#10;&#10;type model struct {&#10;&#9;screen   screen&#10;&#9;quitting bool&#10;&#9;// AddRecord form fields&#10;&#9;key         string&#10;&#9;value       string&#10;&#9;description string&#10;&#9;// Cert management&#10;&#9;certs []string&#10;&#9;// Form state&#10;&#9;adding bool&#10;&#9;// Error/message&#10;&#9;msg string&#10;}&#10;&#10;func initialModel() model {&#10;&#9;return model{&#10;&#9;&#9;screen: mainMenu,&#10;&#9;&#9;certs:  []string{&quot;CertA (valid)&quot;, &quot;CertB (revoked)&quot;, &quot;CertC (valid)&quot;},&#10;&#9;}&#10;}&#10;&#10;func (m model) Init() tea.Cmd {&#10;&#9;return nil&#10;}&#10;&#10;func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {&#10;&#9;switch msg := msg.(type) {&#10;&#9;case tea.KeyMsg:&#10;&#9;&#9;switch msg.String() {&#10;&#9;&#9;case &quot;ctrl+c&quot;, &quot;q&quot;:&#10;&#9;&#9;&#9;m.quitting = true&#10;&#9;&#9;&#9;return m, tea.Quit&#10;&#9;&#9;case &quot;1&quot;:&#10;&#9;&#9;&#9;m.screen = addRecord&#10;&#9;&#9;&#9;return m, nil&#10;&#9;&#9;case &quot;2&quot;:&#10;&#9;&#9;&#9;m.screen = certManagement&#10;&#9;&#9;&#9;return m, nil&#10;&#9;&#9;case &quot;b&quot;:&#10;&#9;&#9;&#9;m.screen = mainMenu&#10;&#9;&#9;&#9;return m, nil&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return m, nil&#10;}&#10;&#10;func (m model) View() string {&#10;&#9;switch m.screen {&#10;&#9;case mainMenu:&#10;&#9;&#9;return mainMenuView()&#10;&#9;case addRecord:&#10;&#9;&#9;return addRecordView(m)&#10;&#9;case certManagement:&#10;&#9;&#9;return certManagementView(m)&#10;&#9;}&#10;&#9;return &quot;&quot;&#10;}&#10;&#10;func mainMenuView() string {&#10;&#9;s := lipgloss.NewStyle().Bold(true).Render(&quot;Gaia Main Menu\n&quot;)&#10;&#9;s += &quot;[1] Add Secret\n&quot;&#10;&#9;s += &quot;[2] Certificate Management\n&quot;&#10;&#9;s += &quot;[q] Quit\n&quot;&#10;&#9;return s&#10;}&#10;&#10;func addRecordView(m model) string {&#10;&#9;form := huh.NewForm(&#10;&#9;&#9;huh.NewInput().Title(&quot;Key&quot;).Value(&amp;m.key),&#10;&#9;&#9;huh.NewInput().Title(&quot;Value&quot;).Value(&amp;m.value),&#10;&#9;&#9;huh.NewInput().Title(&quot;Description&quot;).Value(&amp;m.description),&#10;&#9;)&#10;&#9;return lipgloss.NewStyle().Render(&quot;Add Secret Record\n&quot; + form.View() + &quot;\n[b] Back to menu\n&quot;)&#10;}&#10;&#10;func certManagementView(m model) string {&#10;&#9;s := lipgloss.NewStyle().Render(&quot;Certificate Management\n&quot;)&#10;&#9;for _, c := range m.certs {&#10;&#9;&#9;s += &quot;- &quot; + c + &quot;\n&quot;&#10;&#9;}&#10;&#9;s += &quot;[b] Back to menu\n&quot;&#10;&#9;return s&#10;}&#10;&#10;// Mock gRPC calls&#10;func mockAddSecret(key, value, desc string) {&#10;&#9;fmt.Printf(&quot;[gRPC] AddSecret called: key=%s, value=%s, desc=%s\n&quot;, key, value, desc)&#10;}&#10;&#10;func mockListCerts() []string {&#10;&#9;return []string{&quot;CertA (valid)&quot;, &quot;CertB (revoked)&quot;, &quot;CertC (valid)&quot;}&#10;}&#10;&#10;func Run() error {&#10;&#9;p := tea.NewProgram(initialModel())&#10;&#9;_, err := p.Run()&#10;&#9;return err&#10;}&#10;" />
              <option name="updatedContent" value="package tui&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;tea &quot;github.com/charmbracelet/bubbletea&quot;&#10;&#9;&quot;github.com/charmbracelet/huh&quot;&#10;&#9;&quot;github.com/charmbracelet/lipgloss&quot;&#10;)&#10;&#10;type screen int&#10;&#10;const (&#10;&#9;mainMenu screen = iota&#10;&#9;addRecord&#10;&#9;certManagement&#10;)&#10;&#10;type model struct {&#10;&#9;screen   screen&#10;&#9;quitting bool&#10;&#9;// AddRecord form fields&#10;&#9;key         string&#10;&#9;value       string&#10;&#9;description string&#10;&#9;// Cert management&#10;&#9;certs []string&#10;&#9;// Form state&#10;&#9;adding bool&#10;&#9;// Error/message&#10;&#9;msg string&#10;}&#10;&#10;func initialModel() model {&#10;&#9;return model{&#10;&#9;&#9;screen: mainMenu,&#10;&#9;&#9;certs:  []string{&quot;CertA (valid)&quot;, &quot;CertB (revoked)&quot;, &quot;CertC (valid)&quot;},&#10;&#9;}&#10;}&#10;&#10;func (m model) Init() tea.Cmd {&#10;&#9;return nil&#10;}&#10;&#10;func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {&#10;&#9;switch msg := msg.(type) {&#10;&#9;case tea.KeyMsg:&#10;&#9;&#9;switch msg.String() {&#10;&#9;&#9;case &quot;ctrl+c&quot;, &quot;q&quot;:&#10;&#9;&#9;&#9;m.quitting = true&#10;&#9;&#9;&#9;return m, tea.Quit&#10;&#9;&#9;case &quot;1&quot;:&#10;&#9;&#9;&#9;m.screen = addRecord&#10;&#9;&#9;&#9;return m, nil&#10;&#9;&#9;case &quot;2&quot;:&#10;&#9;&#9;&#9;m.screen = certManagement&#10;&#9;&#9;&#9;return m, nil&#10;&#9;&#9;case &quot;b&quot;:&#10;&#9;&#9;&#9;m.screen = mainMenu&#10;&#9;&#9;&#9;return m, nil&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return m, nil&#10;}&#10;&#10;func (m model) View() string {&#10;&#9;switch m.screen {&#10;&#9;case mainMenu:&#10;&#9;&#9;return mainMenuView()&#10;&#9;case addRecord:&#10;&#9;&#9;return addRecordView(m)&#10;&#9;case certManagement:&#10;&#9;&#9;return certManagementView(m)&#10;&#9;}&#10;&#9;return &quot;&quot;&#10;}&#10;&#10;func mainMenuView() string {&#10;&#9;s := lipgloss.NewStyle().Bold(true).Render(&quot;Gaia Main Menu\n&quot;)&#10;&#9;s += &quot;[1] Add Secret\n&quot;&#10;&#9;s += &quot;[2] Certificate Management\n&quot;&#10;&#9;s += &quot;[q] Quit\n&quot;&#10;&#9;return s&#10;}&#10;&#10;func addRecordView(m model) string {&#10;&#9;form := huh.NewForm(&#10;&#9;&#9;huh.NewGroup(&#10;&#9;&#9;&#9;huh.NewInput().Title(&quot;Key&quot;).Value(&amp;m.key),&#10;&#9;&#9;&#9;huh.NewInput().Title(&quot;Value&quot;).Value(&amp;m.value),&#10;&#9;&#9;&#9;huh.NewInput().Title(&quot;Description&quot;).Value(&amp;m.description),&#10;&#9;&#9;),&#10;&#9;)&#10;&#9;return lipgloss.NewStyle().Render(&quot;Add Secret Record\n&quot; + form.View() + &quot;\n[b] Back to menu\n&quot;)&#10;}&#10;&#10;func certManagementView(m model) string {&#10;&#9;s := lipgloss.NewStyle().Render(&quot;Certificate Management\n&quot;)&#10;&#9;for _, c := range m.certs {&#10;&#9;&#9;s += &quot;- &quot; + c + &quot;\n&quot;&#10;&#9;}&#10;&#9;s += &quot;[b] Back to menu\n&quot;&#10;&#9;return s&#10;}&#10;&#10;// Mock gRPC calls&#10;func mockAddSecret(key, value, desc string) {&#10;&#9;fmt.Printf(&quot;[gRPC] AddSecret called: key=%s, value=%s, desc=%s\n&quot;, key, value, desc)&#10;}&#10;&#10;func mockListCerts() []string {&#10;&#9;return []string{&quot;CertA (valid)&quot;, &quot;CertB (revoked)&quot;, &quot;CertC (valid)&quot;}&#10;}&#10;&#10;func Run() error {&#10;&#9;p := tea.NewProgram(initialModel(), tea.WithAltScreen())&#10;&#9;_, err := p.Run()&#10;&#9;return err&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>